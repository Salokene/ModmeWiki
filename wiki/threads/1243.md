# Detect damage on a model ( NO TRIGGERS )
Game Modding | Call of Duty: Black Ops 3 | Scripting

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Thread By: Harry Bo21<br />[CODE=php]function your_function_name()<br />{<br />	e_model = getEnt( &quot;YOUR_KVP_VALUE&quot;, &quot;script_noteworthy&quot; );<br />	e_model setCanDamage( 1 );<br />    <br />	while ( 1 )<br />	{<br />		e_model waittill( &quot;damage&quot;, damage, attacker, dir, point, mod, model, tag, part, weapon, flags, inflictor, chargeLevel );<br />        <br />		if ( weapon.name == &quot;weapon_name&quot; ) // Optional if you want a certain weapon only to count<br />			break;<br />        <br />	}<br />	<br />	// Your code to run when this model is damaged<br />	playFx( &quot;fx_path\fx_name&quot;, e_model.origin ); // If you want a fx to play on the model when it is damaged<br />	e_model delete(); // If you want the model to delete when shot<br />}[/CODE]</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: mathfag<br />Don&#39;t forget to precache</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: Harry Bo21<br /><blockquote><em>mathfag</em><br />Don&#39;t forget to precache</blockquote><br /> ...<br /> <br />everything in level._effect is precached already<br /> <br />precaching again wastes one of the available 800 fx</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: mathfag<br />You wrote <span style="color:#00ff00;">&quot;fx_path\fx_name&quot;</span> not level._effect[&quot;<span style="color:#00ff00;">fx_path\fx_name</span>&quot;] therefore precache. :)</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: Abnormal202<br /><blockquote><em>mathfag</em><br />You wrote &quot;fx_path\fx_name&quot; not level._effect[&quot;fx_path\fx_name&quot;] therefore precache. :)</blockquote><br /> oh c&#39;mon you&#39;re just being nitpicky on purpose. people should know how FX works, and if not they should know this script is not the place to learn it, as FX isn&#39;t even related to the topic at hand.</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: Harry Bo21<br />Detect damage on a model ( NO TRIGGERS )<br /> <br />Detect damage on a model<br /> <br />not <br /> <br />how to play a fx when a model is shot<br /> <br />i merely advised where to play a fx and how to delete the model - as OPTIONAL extra snippits of info, and the way to do it, not a full tutorial on playing fx<br /> <br />at least my code WORKS so do one</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: eDeK<br />Nice script, by the way, how i can change the &quot;e_model&quot; is a &quot;zombie&quot; and only count the &quot;melee weapons&quot;?<br />How i can detect the player is knifing a zombie?<br />[CODE=php]function your_function_name()<br />{<br />	zombies = level.zombie_team;<br />    <br />	while ( 1 )<br />	{<br />		zombies waittill( &quot;damage&quot;, damage, attacker, dir, point, mod, model, tag, part, weapon, flags, inflictor, chargeLevel );<br />        <br />		if ( weapon.name == &quot;MOD_MELEE&quot; ) // Optional if you want a certain weapon only to count<br />			break;<br />		}        <br />	}<br /><br />	//my code	<br />	<br />}<br />[/CODE]</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: ihmiskeho<br /><blockquote><em>eDeK</em><br />Nice script, by the way, how i can change the &quot;e_model&quot; is a &quot;zombie&quot; and only count the &quot;melee weapons&quot;? How i can detect the player is knifing a zombie? function your_function_name() { zombies = level.zombie_team; while ( 1 ) { zombies waittill( &quot;damage&quot;, damage, attacker, dir, point, mod, model, tag, part, weapon, flags, inflictor, chargeLevel ); if ( weapon.name == &quot;MOD_MELEE&quot; ) // Optional if you want a certain weapon only to count break; } } //my code }</blockquote><br /> <br />[CODE=php]if ( mod == &quot;MOD_MELEE&quot; )[/CODE]<br />Also you should check that the damager is actually a player<br />[CODE=php]if ( mod == &quot;MOD_MELEE&quot; &amp;&amp; IsPlayer(attacker) )[/CODE]</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: eDeK<br />Im doing a Powerup, this function is &quot;when the player knife the zombie&quot;, but not work, i dont know how detect &quot;the player is knifing a zombie&quot;.<br />[CODE=php]function knife_me()<br />{<br />	self endon( &quot;disconnect&quot; );<br />    self endon( &quot;death&quot; );<br />    self endon( &quot;pyrotechnic_done&quot; );<br /><br />    zombies = level.zombie_team;<br />               <br />    zombies waittill( &quot;damage&quot;, damage, attacker, dir, point, mod, model, tag, part, weapon, flags, inflictor, chargeLevel );      <br />    {<br />	    if ( mod == &quot;MOD_MELEE&quot; &amp;&amp; IsPlayer(attacker) )	 <br />	    {<br />	        self fire_works_summon( self );	<br />	    }<br />	}    <br /><br />	WAIT_SERVER_FRAME;	<br />    <br />}[/CODE]<br />Thanks for reply/help.</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: tom5300<br /><blockquote><em>eDeK</em><br />Im doing a Powerup, this function is &quot;when the player knife the zombie&quot;, but not work, i dont know how detect &quot;the player is knifing a zombie&quot;. function knife_me() { self endon( &quot;disconnect&quot; ); self endon( &quot;death&quot; ); self endon( &quot;pyrotechnic_done&quot; ); zombies = level.zombie_team; zombies waittill( &quot;damage&quot;, damage, attacker, dir, point, mod, model, tag, part, weapon, flags, inflictor, chargeLevel ); { if ( mod == &quot;MOD_MELEE&quot; &amp;&amp; IsPlayer(attacker) ) { self fire_works_summon( self ); } } WAIT_SERVER_FRAME; } Thanks for reply/help.</blockquote><br /> You cannot waittill on a variable containing the string &quot;axis&quot;. You will have to iterate through each zombie, and thread a waittill on each zombie.<br /> <br />I&#39;d try something like:<br /> <br />[CODE=php]function knife_me()<br />{<br />    zombies = GetAiTeamArray( level.zombie_team );<br />    foreach(zombie in zombies)<br />    {<br />        zombie thread wait_for_knife();<br />    }<br />}<br />function wait_for_knife()<br />{<br />    self endon( &quot;disconnect&quot; );<br />    self endon( &quot;death&quot; );<br />    self endon( &quot;pyrotechnic_done&quot; );<br />    while(1)<br />    {<br />        self waittill( &quot;damage&quot;, damage, attacker, dir, point, mod, model, tag, part, weapon, flags, inflictor, chargeLevel );<br />        if ( mod == &quot;MOD_MELEE&quot; &amp;&amp; IsPlayer(attacker) )	 <br />        {<br />            self fire_works_summon( self );	<br />        }<br />        WAIT_SERVER_FRAME;<br />    }<br />}[/CODE]<br /> <br />Note: I have not tested this code, hope it&#39;s error free.</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: eDeK<br />Thanks for reply Tom but dont work it.<br />I need like <a href="https://aviacreations.com/modme/index.php?view=forumprofile&uid=381">&lt;span style=&quot;color:#ffffff;&quot;&gt;ihmiskeho&lt;/span&gt;</a> say &quot;the damager is actually a player&quot;.<br />Is something like that:<br />[CODE=php]if(isdefined(attacker) &amp;&amp; attacker.team != self.team &amp;&amp; !isdefined(attacker.playername))  <br />{<br />	if ( mod == &quot;MOD_MELEE&quot; &amp;&amp; IsPlayer(attacker) )	 <br />    {<br />        self fire_works_summon( self );	<br />    }<br />}[/CODE]<br />But this no work too. :(</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: mathfag<br />[CODE=php]zm_spawner::register_zombie_damage_callback( &amp;knife_dmg ); //in function main<br /><br />//when a AI is damaged, this will run<br />//self = AI<br />function knife_dmg(str_mod, str_hit_location, v_hit_origin, e_player, n_amount, w_weapon, direction_vec, tagName, modelName, partName, dFlags, inflictor, chargeLevel) <br />{<br /><br />if(str_mod == &quot;MOD_MELEE&quot;)<br />	self thread fire_works_summon();<br /><br />}<br /><br />function fire_works_summon()<br />{<br />//use this new function or you may run into problems<br /><br /><br />}[/CODE]</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: eDeK<br />Works fine Mathfag, thanks for reply dude, the problem is when i grab the powerup the &quot;Knifing effect (fireworks)&quot; dont stop, still active after the powerup is over.<br />[CODE=php]function __init__()<br />{<br />	<br />	zm_powerups::register_powerup( &quot;pyrotechnic&quot;, &amp;grab_pyrotechnic );<br />	if( ToLower( GetDvarString( &quot;g_gametype&quot; ) ) != &quot;pyrotechnic&quot; )<br />	{<br />		zm_powerups::add_zombie_powerup( &quot;pyrotechnic&quot;, &quot;pyrotechnic_powerup_model&quot;, &quot;&quot;, &amp;zm_powerups::func_should_always_drop, POWERUP_ONLY_AFFECTS_GRABBER, !POWERUP_ANY_TEAM, !POWERUP_ZOMBIE_GRABBABLE );						<br />	} <br />}<br /><br />function grab_pyrotechnic( player )<br />{<br />	player PlayLocalSound(&quot;vox_pyrotechnic&quot;);<br />	skip = player add_powerup_hud( &quot;pyrotechnic_material_hud&quot;, N_POWERUP_DEFAULT_TIME );<br />    zm_spawner::register_zombie_damage_callback( &amp;knife_dmg );    <br /><br />	if( skip )<br />		return; <br />	<br />	if( isdefined(player.pyrotechnic_active) )<br />		return;		<br />	<br />	player thread do_pyrotechnic();<br />}<br /><br />function do_pyrotechnic()<br />{<br />	self.pyrotechnic_active = true;<br /><br />    self notify( &quot;pyrotechnic_done&quot; );<br />    self endon( &quot;disconnect&quot; );<br />    self endon( &quot;death&quot; );<br />    self endon( &quot;pyrotechnic_done&quot; );<br /><br />    self thread knife_dmg();	<br />}<br /><br />function knife_dmg(str_mod, str_hit_location, v_hit_origin, e_player, n_amount, w_weapon, direction_vec, tagName, modelName, partName, dFlags, inflictor, chargeLevel) <br />{		<br />    self endon( &quot;disconnect&quot; );<br />    self endon( &quot;death&quot; );<br />    self endon( &quot;pyrotechnic_done&quot; );<br /><br />	if(str_mod == &quot;MOD_MELEE&quot;)<br />	{<br />		self thread fire_works_summon( e_player, w_weapon );<br />	}<br /><br />	WAIT_SERVER_FRAME;<br />}<br />[/CODE]</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: mathfag<br />Put this in __init__. It should only be activated once.<br />[CODE=php]zm_spawner::register_zombie_damage_callback( &amp;knife_dmg );[/CODE]<br /> <br />Remove<br />[CODE=php]self thread knife_dmg();[/CODE]<br /> <br />Replace<br />[CODE=php]self.pyrotechnic_active = true;[/CODE]<br />with<br />[CODE=php]level.pyrotechnic_active = true;[/CODE]<br /> <br />Replace function knife_dmg() with<br />[CODE=php]function knife_dmg(str_mod, str_hit_location, v_hit_origin, e_player, n_amount, w_weapon, direction_vec, tagName, modelName, partName, dFlags, inflictor, chargeLevel) <br />{		<br /><br />if(level.pyrotechnic_active == 0)<br />return 0;<br /><br />	if(str_mod == &quot;MOD_MELEE&quot;)<br />	{<br />		self thread fire_works_summon( e_player, w_weapon );<br />	}<br /><br />	WAIT_SERVER_FRAME;<br />}[/CODE]<br /> <br />Make sure<br />[CODE=php]level.pyrotechnic_active[/CODE]<br />is set to false when the powerup is over</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: eDeK<br />I do all you say. <br />When i spawn in the game (I shoot the zombies, i cant do points and the &quot;Knife effect is active&quot;).<br />After this, i grab the powerup (I shoot the zombies, i can do points but the &quot;Knife effect is no active&quot; even after powerup is over.&quot;).<br />Very weird all, i gonna still testing but at the moment i have this.<br />[CODE=php]//POWERUP<br />function __init__()<br />{	<br />	zm_powerups::register_powerup( &quot;pyrotechnic&quot;, &amp;grab_pyrotechnic );<br />	if( ToLower( GetDvarString( &quot;g_gametype&quot; ) ) != &quot;pyrotechnic&quot; )<br />	{<br />		zm_powerups::add_zombie_powerup( &quot;pyrotechnic&quot;, &quot;pyrotechnic_powerup_model&quot;, &quot;&quot;, &amp;zm_powerups::func_should_always_drop, POWERUP_ONLY_AFFECTS_GRABBER, !POWERUP_ANY_TEAM, !POWERUP_ZOMBIE_GRABBABLE );<br />		zm_spawner::register_zombie_damage_callback( &amp;knife_dmg );					<br />	} <br />}<br /><br />function grab_pyrotechnic( player )<br />{<br />	player PlayLocalSound(&quot;vox_pyrotechnic&quot;);<br />	skip = player add_powerup_hud( &quot;pyrotechnic_material_hud&quot;, N_POWERUP_DEFAULT_TIME );    	<br /><br />	if( skip )<br />		return; <br />	<br />	if( isdefined(player.pyrotechnic_active) )<br />		return;		<br />	<br />	player thread do_pyrotechnic();<br />}<br /><br />function do_pyrotechnic()<br />{<br />	level.pyrotechnic_active = true;<br /><br />    self notify( &quot;pyrotechnic_done&quot; );<br />    self endon( &quot;disconnect&quot; );<br />    self endon( &quot;death&quot; );<br />    self endon( &quot;pyrotechnic_done&quot; );    <br />}<br /><br />function knife_dmg(str_mod, str_hit_location, v_hit_origin, e_player, n_amount, w_weapon, direction_vec, tagName, modelName, partName, dFlags, inflictor, chargeLevel) <br />{		<br /><br />	if(level.pyrotechnic_active == 0)<br />	return 0;<br /><br />	if(str_mod == &quot;MOD_MELEE&quot;)<br />	{<br />		self thread fire_works_summon( e_player, w_weapon );<br />	}<br /><br />	WAIT_SERVER_FRAME;<br />}<br /><br />//HUD<br />function wait_til_timeout( player, hud )//player = self;<br />{<br />	while( hud.time &gt; 0 )<br />	{<br />		wait(1);<br />		hud.time--; 		<br />	}<br />	<br />	player notify( &quot;pyrotechnic_done&quot; );<br />	player remove_powerup_hud( &quot;pyrotechnic_material_hud&quot; );<br />	player.pyrotechnic_active = undefined;<br />	<br />	<br />}<br /><br />function add_powerup_hud( powerup, timer )<br />{<br />	if ( !isDefined( self.powerup_hud ) )<br />		self.powerup_hud = [];<br />	<br />	if( isDefined( self.powerup_hud[powerup] ) )<br />	{<br />		self.powerup_hud[powerup].time = timer; <br />		return true; // tells to skip because powerup is already active<br />				<br />	}<br />	<br />	self endon( &quot;disconnect&quot; );<br />	hud = NewClientHudElem( self );<br />	hud.powerup = powerup;<br />	hud.foreground = true;<br />	hud.hidewheninmenu = true;<br />	hud.alignX = &quot;center&quot;;<br />	hud.alignY = &quot;bottom&quot;;<br />	hud.horzAlign = &quot;center&quot;;<br />	hud.vertAlign = &quot;bottom&quot;;<br />	hud.x = hud.x;<br />	hud.y = hud.y - 50;<br />	hud.alpha = 1;<br />	hud SetShader( powerup , 64, 64 );<br />	hud scaleOverTime( .5, 32, 32 );<br />	hud.time = timer;<br />	hud thread harrybo21_blink_powerup_hud();<br />	thread wait_til_timeout( self, hud ); <br />	<br />	self.powerup_hud[ powerup ] = hud;<br />	<br />	a_keys = GetArrayKeys( self.powerup_hud );<br />	for ( i = 0; i &lt; a_keys.size; i++ )<br />	 	self.powerup_hud[ a_keys<em>] thread move_hud( .5, 0 - ( 24 * ( self.powerup_hud.size ) ) + ( i * 37.5 ) + 25, self.powerup_hud[ a_keys<em>].y );<br />	<br />	//return false;  // powerup is not already active<br />	level.pyrotechnic_active = false;<br />		<br /><br />}<br /><br />function move_hud( time, x, y )<br />{<br />	self moveOverTime( time );<br />	self.x = x;<br />	self.y = y;<br />}<br /><br />function harrybo21_blink_powerup_hud()<br />{<br />	self endon( &quot;delete&quot; );<br />	self endon( &quot;stop_fade&quot; );<br />	while( isDefined( self ) )<br />	{<br />		if ( self.time &gt;= 20 )<br />		{<br />			self.alpha = 1; <br />			wait .1;<br />			continue;<br />		}<br />		fade_time = 1;<br />		if ( self.time &lt; 10 )<br />			fade_time = .5;<br />		if ( self.time &lt; 5 )<br />			fade_time = .25;<br />			<br />		self fadeOverTime( fade_time );<br />		self.alpha = !self.alpha;<br />		<br />		wait( fade_time );<br />	}<br />}<br /><br />function remove_powerup_hud( powerup )<br />{<br />	self.powerup_hud[ powerup ] destroy();<br />	self.powerup_hud[ powerup ] notify( &quot;stop_fade&quot; );<br />	self.powerup_hud[ powerup ] fadeOverTime( .2 );<br />	self.alpha = 0;<br />	wait .2;<br />	self.powerup_hud[ powerup ] delete();<br />	self.powerup_hud[ powerup ] = undefined;<br />	self.powerup_hud = array::remove_index( self.powerup_hud, self.powerup_hud[ powerup ], true );<br />	<br />	a_keys = GetArrayKeys( self.powerup_hud );<br />	for ( i = 0; i &lt; a_keys.size; i++ )<br />	 	self.powerup_hud[ a_keys<em>] thread move_hud( .5, 0 - ( 24 * ( self.powerup_hud.size ) ) + ( i * 37.5 ) + 25, self.powerup_hud[ a_keys<em>].y );<br />}<br /><br /><br />//FIREWORKS<br />// Checks to see if fire works is running<br />// self == zombie<br />function fire_works_zombie_validation()<br />{<br />	if( IS_TRUE( self.barricade_enter ) )<br />	{<br />		return false;<br />	}<br />	<br />	if ( IS_TRUE( self.is_traversing ) )<br />	{<br />		return false;<br />	}<br /><br />	if( !IS_TRUE( self.completed_emerging_into_playable_area ) &amp;&amp; !IsDefined( self.first_node ) )<br />	{<br />		return false;<br />	}<br /><br />	if ( IS_TRUE( self.is_leaping ) )<br />	{<br />		return false;<br />	}<br />	<br />	return true;<br />}<br /><br />// Summons the player&#39;s current gun to pop up and fire in a circle for a period of time<br />// immune_result_direct == target is immune to death gib<br />// immune_result_indirect == target is immune to death gib on hit from the magic bullet<br />// self == target zombie<br />function fire_works_summon( e_player, w_weapon )<br />{<br />	w_summoned_weapon = e_player GetCurrentWeapon();<br />	v_target_zombie_origin = self.origin;<br />	<br />	// Checks if self is immune_result_direct == true. If so, do not kill self<br />	if ( !IS_TRUE( level.aat[ ZM_AAT_FIRE_WORKS_NAME ].immune_result_direct[ self.archetype ] ) )<br />	{<br />		self thread zombie_death_gib( e_player, w_weapon, e_player );<br />	}<br /><br />	// Spawns base model<br />	v_firing_pos = v_target_zombie_origin + ZM_AAT_FIRE_WORKS_ZOMBIE_GUN_HEIGHT;<br />	v_start_yaw = VectorToAngles( v_firing_pos - v_target_zombie_origin );<br />	v_start_yaw = (0, v_start_yaw[1], 0);<br />	mdl_weapon = zm_utility::spawn_weapon_model( w_summoned_weapon, undefined, v_target_zombie_origin, v_start_yaw );<br /><br />	// Stat tracking definitions<br />	mdl_weapon.owner = e_player;<br />	mdl_weapon.b_aat_fire_works_weapon = true;<br />	mdl_weapon.allow_zombie_to_target_ai = true; // lets the zombie damage callbacks pass through damage from this<br />	<br />	// Fires FX<br />	mdl_weapon thread clientfield::set( ZM_AAT_FIRE_WORKS_NAME, 1 );<br />	<br />	// Moves weapon upwards to firing position<br />	mdl_weapon MoveTo( v_firing_pos, ZM_AAT_FIRE_WORKS_SUMMON_TIME );<br />	mdl_weapon waittill( &quot;movedone&quot; );<br /><br />	// Starts firing<br />	for ( i = 0; i &lt; ZM_AAT_FIRE_WORKS_FIRING_NUM_FRAMES; i++ )<br />	{<br />		zombie = mdl_weapon zm_aat_fire_works_get_target();<br />		if ( !IsDefined( zombie ) )<br />		{<br />			//if no target available, just pick a random yaw<br />			v_curr_yaw = (0, RandomIntRange( 0, 360 ), 0);<br />			v_target_pos = mdl_weapon.origin + VectorScale( AnglesToForward( v_curr_yaw ), 40 );<br />		}<br />		else<br />		{<br />			v_target_pos = zombie GetCentroid();<br />		}<br /><br />		mdl_weapon.angles = VectorToAngles( v_target_pos - mdl_weapon.origin );<br />		v_flash_pos = mdl_weapon GetTagOrigin( &quot;tag_flash&quot; );<br />		mdl_weapon DontInterpolate();<br /><br />		// MagicBullet shots are credited to the model rather than player, as MagicBullet causes recoil on player<br />		MagicBullet( w_summoned_weapon, v_flash_pos, v_target_pos, mdl_weapon );<br /><br />		util::wait_network_frame();<br />	}<br /><br />	mdl_weapon MoveTo( v_target_zombie_origin, ZM_AAT_FIRE_WORKS_SUMMON_TIME );<br />	mdl_weapon waittill( &quot;movedone&quot; );<br />	<br />	mdl_weapon clientfield::set( ZM_AAT_FIRE_WORKS_NAME, 0 );<br />	<br />	util::wait_network_frame(); // Waits for FX to complete<br />	util::wait_network_frame(); // extra waits for theater playback<br />	util::wait_network_frame(); // extra waits for theater playback<br />	<br />	mdl_weapon Delete();<br />	wait .25; // Delay for final projectile-based gun shots to finish firing<br />}<br /><br />// Death callback for zombies killed by summoned Fire Works weapon<br />function zm_aat_fire_works_get_target()<br />{<br />	a_ai_zombies = array::randomize( GetAiTeamArray( &quot;axis&quot; ) );<br /><br />	los_checks = 0;<br />	for ( i = 0; i &lt; a_ai_zombies.size; i++ )<br />	{<br />		zombie = a_ai_zombies<em>;<br />		test_origin = zombie getcentroid();<br />		if ( DistanceSquared( self.origin, test_origin ) &gt; ZM_AAT_FIRE_WORKS_RANGE_SQ )<br />		{<br />			continue;<br />		}<br /><br />		if ( los_checks &lt; ZM_AAT_FIRE_WORKS_MAX_LOS_CHECKS &amp;&amp; !zombie DamageConeTrace( self.origin ) )<br />		{<br />			los_checks++;<br />			continue;<br />		}<br /><br />		return zombie;<br />	}<br /><br />	if ( a_ai_zombies.size )<br />	{<br />		// just return the first one, so that we at least change direction<br />		return a_ai_zombies[0];<br />	}<br /><br />	return undefined;<br />}<br /><br />// self is a zombie<br />function zm_aat_fire_works_zombie_damage_response( str_mod, str_hit_location, v_hit_origin, e_attacker, n_amount, w_weapon, direction_vec, tagName, modelName, partName, dFlags, inflictor, chargeLevel )<br />{<br />	if ( IS_TRUE( level.aat[ ZM_AAT_FIRE_WORKS_NAME ].immune_result_indirect[ self.archetype ] ) )<br />	{<br />		return false;<br />	}<br /><br />	if ( IS_TRUE( e_attacker.b_aat_fire_works_weapon ) )<br />	{<br />		self thread zombie_death_gib( e_attacker, w_weapon, e_attacker.owner );<br />		return true;<br />	}<br /><br />	return false;<br />}<br /><br />// Death callback for zombies killed by summoned Fire Works weapon<br />function zm_aat_fire_works_death_callback( attacker )<br />{<br />	if ( isdefined( attacker ) )<br />	{<br />		if ( IS_TRUE( attacker.b_aat_fire_works_weapon ) )<br />		{<br />			// Checks if player has disconnected<br />			if ( isdefined( attacker.owner ) )<br />			{<br />				e_attacking_player = attacker.owner;<br />				// TODO set up stat tracking<br />			}<br />		}<br />	}<br />}<br /><br />// Gibs and Kills zombie<br />// self == affected zombie<br />// e_attacker == the script_model of the gun (needs to do the damage, so the player doesn&#39;t receive kickback)<br />// w_weapon == the weapon to apply damage using<br />// e_owner == the owner of the gun (for awarding challenge stat progress)<br />function zombie_death_gib( e_attacker, w_weapon, e_owner )<br />{<br />	gibserverutils::gibhead( self );<br />	<br />	if ( math::cointoss() )<br />	{<br />		gibserverutils::gibleftarm( self );<br />	}<br />	else<br />	{<br />		gibserverutils::gibrightarm( self );<br />	}<br />	<br />	gibserverutils::giblegs( self );<br />	<br />	self DoDamage( self.health, self.origin, e_attacker, w_weapon, &quot;torso_upper&quot; );<br /><br />	if ( IsDefined( e_owner ) &amp;&amp; IsPlayer( e_owner ) )<br />	{<br />		e_owner zm_stats::increment_challenge_stat( &quot;ZOMBIE_HUNTER_FIRE_WORKS&quot; );<br />	}<br />}<br />[/CODE]<br />Thanks for your time Mathfag.</em></em></em></em></em></p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: mathfag<br />in grab_pyrotechnic change <br />[CODE=php]if( isdefined(player.pyrotechnic_active) )[/CODE]<br /> <br />to<br />[CODE=php]if( isdefined(player.pyrotechnic_active) &amp;&amp; player.pyrotechnic_active == 1 )[/CODE]<br /> <br />just incase.<br /> <br /> <br />The problem is that you set <br />[CODE=php]level.pyrotechnic_active = false;[/CODE]<br /> <br />immediately after setting it to true. Actually you did it before but im guessing since the cpu has to process a bunch of code it gets set after.<br />anyway<br />Move<br />[CODE=php]level.pyrotechnic_active = false;[/CODE]<br /> <br />to the end of <br />[CODE=php]function wait_til_timeout[/CODE]</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: eDeK<br /><blockquote><em>mathfag</em><br />in grab_pyrotechnic change  if( isdefined(player.pyrotechnic_active) )   to if( isdefined(player.pyrotechnic_active) &amp;&amp; player.pyrotechnic_active == 1 )   just incase.     The problem is that you set  level.pyrotechnic_active = false;   immediately after setting it to true. Actually you did it before but im guessing since the cpu has to process a bunch of code it gets set after. anyway Move level.pyrotechnic_active = false;   to the end of  function wait_til_timeout    </blockquote><br /> I dont have words to describe my gratitude with you, seriously, thanks.<br /><br /> <br />When i spawn in the game the &quot;Knife effect&quot; is active, i grab the powerup for the first time, the &quot;Knife effect&quot; still active, when the powerup is over, the &quot;Knife effect&quot; is over. (Everything goes back to normal)<br /> <br />I grab the powerup for the second time, the powerup is working perfect all the time.<br />[CODE=php]//POWERUP<br />function __init__()<br />{	<br />	zm_powerups::register_powerup( &quot;pyrotechnic&quot;, &amp;grab_pyrotechnic );<br />	if( ToLower( GetDvarString( &quot;g_gametype&quot; ) ) != &quot;pyrotechnic&quot; )<br />	{<br />		zm_powerups::add_zombie_powerup( &quot;pyrotechnic&quot;, &quot;pyrotechnic_powerup_model&quot;, &quot;&quot;, &amp;zm_powerups::func_should_always_drop, POWERUP_ONLY_AFFECTS_GRABBER, !POWERUP_ANY_TEAM, !POWERUP_ZOMBIE_GRABBABLE );<br />		zm_spawner::register_zombie_damage_callback( &amp;knife_dmg );					<br />	} <br />}<br /><br />function grab_pyrotechnic( player )<br />{<br />	player PlayLocalSound(&quot;vox_pyrotechnic&quot;);<br />	skip = player add_powerup_hud( &quot;pyrotechnic_material_hud&quot;, N_POWERUP_DEFAULT_TIME );    	<br /><br />	if( skip )<br />		return; <br />	<br />	if( isdefined(player.pyrotechnic_active) &amp;&amp; player.pyrotechnic_active == 1 )<br />		return;		<br />	<br />	player thread do_pyrotechnic();<br /><br />}<br /><br />function do_pyrotechnic()<br />{<br />	level.pyrotechnic_active = true;<br /><br />    self notify( &quot;pyrotechnic_done&quot; );<br />    self endon( &quot;disconnect&quot; );<br />    self endon( &quot;death&quot; );<br />    self endon( &quot;pyrotechnic_done&quot; );<br /><br />       <br />}<br /><br />function knife_dmg(str_mod, str_hit_location, v_hit_origin, e_player, n_amount, w_weapon, direction_vec, tagName, modelName, partName, dFlags, inflictor, chargeLevel) <br />{		<br /><br />	if(level.pyrotechnic_active == 0)<br />	return 0;<br /><br />	if(str_mod == &quot;MOD_MELEE&quot;)<br />	{<br />		self thread fire_works_summon( e_player, w_weapon );<br />	}<br /><br />	WAIT_SERVER_FRAME;<br />}<br /><br />//HUD<br />function wait_til_timeout( player, hud )//player = self;<br />{<br />	while( hud.time &gt; 0 )<br />	{<br />		wait(1);<br />		hud.time--; 		<br />	}<br />	<br />	player notify( &quot;pyrotechnic_done&quot; );<br />	player remove_powerup_hud( &quot;pyrotechnic_material_hud&quot; );<br />	player.pyrotechnic_active = undefined;<br />	level.pyrotechnic_active = false;<br />	<br />	<br />}<br /><br />function add_powerup_hud( powerup, timer )<br />{<br />	if ( !isDefined( self.powerup_hud ) )<br />		self.powerup_hud = [];<br />	<br />	if( isDefined( self.powerup_hud[powerup] ) )<br />	{<br />		self.powerup_hud[powerup].time = timer; <br />		return true; // tells to skip because powerup is already active<br />				<br />	}<br />	<br />	self endon( &quot;disconnect&quot; );<br />	hud = NewClientHudElem( self );<br />	hud.powerup = powerup;<br />	hud.foreground = true;<br />	hud.hidewheninmenu = true;<br />	hud.alignX = &quot;center&quot;;<br />	hud.alignY = &quot;bottom&quot;;<br />	hud.horzAlign = &quot;center&quot;;<br />	hud.vertAlign = &quot;bottom&quot;;<br />	hud.x = hud.x;<br />	hud.y = hud.y - 50;<br />	hud.alpha = 1;<br />	hud SetShader( powerup , 64, 64 );<br />	hud scaleOverTime( .5, 32, 32 );<br />	hud.time = timer;<br />	hud thread harrybo21_blink_powerup_hud();<br />	thread wait_til_timeout( self, hud ); <br />	<br />	self.powerup_hud[ powerup ] = hud;<br />	<br />	a_keys = GetArrayKeys( self.powerup_hud );<br />	for ( i = 0; i &lt; a_keys.size; i++ )<br />	 	self.powerup_hud[ a_keys<em>] thread move_hud( .5, 0 - ( 24 * ( self.powerup_hud.size ) ) + ( i * 37.5 ) + 25, self.powerup_hud[ a_keys<em>].y );<br />	<br />	return false;  // powerup is not already active<br />}<br /><br /><br /><br /><br />function move_hud( time, x, y )<br />{<br />	self moveOverTime( time );<br />	self.x = x;<br />	self.y = y;<br />}<br /><br />function harrybo21_blink_powerup_hud()<br />{<br />	self endon( &quot;delete&quot; );<br />	self endon( &quot;stop_fade&quot; );<br />	while( isDefined( self ) )<br />	{<br />		if ( self.time &gt;= 20 )<br />		{<br />			self.alpha = 1; <br />			wait .1;<br />			continue;<br />		}<br />		fade_time = 1;<br />		if ( self.time &lt; 10 )<br />			fade_time = .5;<br />		if ( self.time &lt; 5 )<br />			fade_time = .25;<br />			<br />		self fadeOverTime( fade_time );<br />		self.alpha = !self.alpha;<br />		<br />		wait( fade_time );<br />	}<br />}<br /><br />function remove_powerup_hud( powerup )<br />{<br />	self.powerup_hud[ powerup ] destroy();<br />	self.powerup_hud[ powerup ] notify( &quot;stop_fade&quot; );<br />	self.powerup_hud[ powerup ] fadeOverTime( .2 );<br />	self.alpha = 0;<br />	wait .2;<br />	self.powerup_hud[ powerup ] delete();<br />	self.powerup_hud[ powerup ] = undefined;<br />	self.powerup_hud = array::remove_index( self.powerup_hud, self.powerup_hud[ powerup ], true );<br />	<br />	a_keys = GetArrayKeys( self.powerup_hud );<br />	for ( i = 0; i &lt; a_keys.size; i++ )<br />	 	self.powerup_hud[ a_keys<em>] thread move_hud( .5, 0 - ( 24 * ( self.powerup_hud.size ) ) + ( i * 37.5 ) + 25, self.powerup_hud[ a_keys<em>].y );<br />}<br />[/CODE]</em></em></em></em></p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: mathfag<br /><blockquote><em>eDeK</em><br />mathfag in grab_pyrotechnic change  if( isdefined(player.pyrotechnic_active) )   to if( isdefined(player.pyrotechnic_active) &amp;&amp; player.pyrotechnic_active == 1 )   just incase.     The problem is that you set  level.pyrotechnic_active = false;   immediately after setting it to true. Actually you did it before but im guessing since the cpu has to process a bunch of code it gets set after. anyway Move level.pyrotechnic_active = false;   to the end of  function wait_til_timeout      I dont have words to describe my gratitude with you, seriously, thanks.   When i spawn in the game the &quot;Knife effect&quot; is active, i grab the powerup for the first time, the &quot;Knife effect&quot; still active, when the powerup is over, the &quot;Knife effect&quot; is over. (Everything goes back to normal)   I grab the powerup for the second time, the powerup is working perfect all the time. //POWERUP function __init__() { zm_powerups::register_powerup( &quot;pyrotechnic&quot;, &amp;grab_pyrotechnic ); if( ToLower( GetDvarString( &quot;g_gametype&quot; ) ) != &quot;pyrotechnic&quot; ) { zm_powerups::add_zombie_powerup( &quot;pyrotechnic&quot;, &quot;pyrotechnic_powerup_model&quot;, &quot;&quot;, &amp;zm_powerups::func_should_always_drop, POWERUP_ONLY_AFFECTS_GRABBER, !POWERUP_ANY_TEAM, !POWERUP_ZOMBIE_GRABBABLE ); zm_spawner::register_zombie_damage_callback( &amp;knife_dmg ); } } function grab_pyrotechnic( player ) { player PlayLocalSound(&quot;vox_pyrotechnic&quot;); skip = player add_powerup_hud( &quot;pyrotechnic_material_hud&quot;, N_POWERUP_DEFAULT_TIME ); if( skip ) return; if( isdefined(player.pyrotechnic_active) &amp;&amp; player.pyrotechnic_active == 1 ) return; player thread do_pyrotechnic(); } function do_pyrotechnic() { level.pyrotechnic_active = true; self notify( &quot;pyrotechnic_done&quot; ); self endon( &quot;disconnect&quot; ); self endon( &quot;death&quot; ); self endon( &quot;pyrotechnic_done&quot; ); } function knife_dmg(str_mod, str_hit_location, v_hit_origin, e_player, n_amount, w_weapon, direction_vec, tagName, modelName, partName, dFlags, inflictor, chargeLevel) { if(level.pyrotechnic_active == 0) return 0; if(str_mod == &quot;MOD_MELEE&quot;) { self thread fire_works_summon( e_player, w_weapon ); } WAIT_SERVER_FRAME; } //HUD function wait_til_timeout( player, hud )//player = self; { while( hud.time &gt; 0 ) { wait(1); hud.time--; } player notify( &quot;pyrotechnic_done&quot; ); player remove_powerup_hud( &quot;pyrotechnic_material_hud&quot; ); player.pyrotechnic_active = undefined; level.pyrotechnic_active = false; } function add_powerup_hud( powerup, timer ) { if ( !isDefined( self.powerup_hud ) ) self.powerup_hud = []; if( isDefined( self.powerup_hud[powerup] ) ) { self.powerup_hud[powerup].time = timer; return true; // tells to skip because powerup is already active } self endon( &quot;disconnect&quot; ); hud = NewClientHudElem( self ); hud.powerup = powerup; hud.foreground = true; hud.hidewheninmenu = true; hud.alignX = &quot;center&quot;; hud.alignY = &quot;bottom&quot;; hud.horzAlign = &quot;center&quot;; hud.vertAlign = &quot;bottom&quot;; hud.x = hud.x; hud.y = hud.y - 50; hud.alpha = 1; hud SetShader( powerup , 64, 64 ); hud scaleOverTime( .5, 32, 32 ); hud.time = timer; hud thread harrybo21_blink_powerup_hud(); thread wait_til_timeout( self, hud ); self.powerup_hud[ powerup ] = hud; a_keys = GetArrayKeys( self.powerup_hud ); for ( i = 0; i &lt; a_keys.size; i++ ) self.powerup_hud[ a_keys<em>] thread move_hud( .5, 0 - ( 24 * ( self.powerup_hud.size ) ) + ( i * 37.5 ) + 25, self.powerup_hud[ a_keys<em>].y ); return false; // powerup is not already active } function move_hud( time, x, y ) { self moveOverTime( time ); self.x = x; self.y = y; } function harrybo21_blink_powerup_hud() { self endon( &quot;delete&quot; ); self endon( &quot;stop_fade&quot; ); while( isDefined( self ) ) { if ( self.time &gt;= 20 ) { self.alpha = 1; wait .1; continue; } fade_time = 1; if ( self.time &lt; 10 ) fade_time = .5; if ( self.time &lt; 5 ) fade_time = .25; self fadeOverTime( fade_time ); self.alpha = !self.alpha; wait( fade_time ); } } function remove_powerup_hud( powerup ) { self.powerup_hud[ powerup ] destroy(); self.powerup_hud[ powerup ] notify( &quot;stop_fade&quot; ); self.powerup_hud[ powerup ] fadeOverTime( .2 ); self.alpha = 0; wait .2; self.powerup_hud[ powerup ] delete(); self.powerup_hud[ powerup ] = undefined; self.powerup_hud = array::remove_index( self.powerup_hud, self.powerup_hud[ powerup ], true ); a_keys = GetArrayKeys( self.powerup_hud ); for ( i = 0; i &lt; a_keys.size; i++ ) self.powerup_hud[ a_keys<em>] thread move_hud( .5, 0 - ( 24 * ( self.powerup_hud.size ) ) + ( i * 37.5 ) + 25, self.powerup_hud[ a_keys<em>].y ); }</em></em></em></em></blockquote><em><em><em><em>in function __init__ add <br />[CODE=php]level.pyrotechnic_active = 0;[/CODE]<br /> <br />because if you do<br />[CODE=php]if(level.pyrotechnic_active == 0)[/CODE]<br /> <br />when it&#39;s undefined it screws up<br /> <br />also the line<br />[CODE=php]if( ToLower( GetDvarString( &quot;g_gametype&quot; ) ) != &quot;pyrotechnic&quot; )[/CODE]<br />is pointless</em></em></em></em></p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: eDeK<br />Yeah, the line is:<br />[CODE=php]if( ToLower( GetDvarString( &quot;g_gametype&quot; ) ) != &quot;zcleansed&quot; )[/CODE]<br />My fault writing, work perfect now, thanks again, the unique thing i need buff is the score &quot;i cant do points, shooting or knifing, with the powerup active&quot; i dont know why, i need to do a callback to the player/zombie?</p>
