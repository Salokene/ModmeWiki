# Remove damage by fall
Game Modding | Call of Duty: Black Ops 3 | Scripting

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Thread By: ByKris<br />How can remove damage by fall?</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: natesmithzombies<br />You need to override the stock player_damage_override function. To do so: <br /><br /><br /><br />1) paste this at the bottom of your mapname.gsc <br /><br /><br /><br />[CODE=php]function player_damage_override( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime )<br />{<br /> iDamage = self check_player_damage_callbacks( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime );<br /> <br /> if( sMeansOfDeath == &quot;MOD_FALLING&quot; ) // No Fall Damage<br /> return 0; <br /> <br /> if( self.scene_takedamage === false )<br /> {<br /> return 0;<br /> }<br /> <br /> if ( IS_TRUE( self.use_adjusted_grenade_damage ) )<br />    {<br />        self.use_adjusted_grenade_damage = undefined;<br />        if( ( self.health &gt; iDamage ) )<br />        {<br />         return iDamage;<br />        }<br />    }<br /><br /> if ( !iDamage )<br /> {<br /> return 0;<br /> }<br /> <br /> // WW (8/20/10) - Sledgehammer fix for Issue 43492. This should stop the player from taking any damage while in laststand<br /> if( self laststand::player_is_in_laststand() )<br /> {<br /> return 0;<br /> }<br /> <br /> if ( isDefined( eInflictor ) )<br /> {<br /> if ( IS_TRUE( eInflictor.water_damage ) )<br /> {<br /> return 0;<br /> }<br /> }<br /><br /> if ( isDefined( eAttacker ) )<br /> {<br /> if( IS_EQUAL( eAttacker.owner, self ) ) <br /> {<br /> return 0;<br /> }<br /> <br /> if( isDefined( self.ignoreAttacker ) &amp;&amp; self.ignoreAttacker == eAttacker ) <br /> {<br /> return 0;<br /> }<br /> <br /> // AR (5/30/12) - Stop Zombie players from damaging other Zombie players<br /> if ( IS_TRUE( self.is_zombie ) &amp;&amp; IS_TRUE( eAttacker.is_zombie ) )<br /> {<br /> return 0;<br /> }<br /> <br /> if( (isDefined( eAttacker.is_zombie ) &amp;&amp; eAttacker.is_zombie) )<br /> {<br /> self.ignoreAttacker = eAttacker;<br /> self thread remove_ignore_attacker();<br /><br /> if ( isdefined( eAttacker.custom_damage_func ) )<br /> {<br /> iDamage = eAttacker [[ eAttacker.custom_damage_func ]]( self );<br /> }<br /> }<br /> <br /> eAttacker notify( &quot;hit_player&quot; ); <br /><br /> if ( isdefined( eAttacker ) &amp;&amp; isdefined( eAttacker.func_mod_damage_override ) )<br /> {<br /> sMeansOfDeath = eAttacker [[ eAttacker.func_mod_damage_override ]]( eInflictor, sMeansOfDeath, weapon );<br /> }<br /> <br /> if( sMeansOfDeath != &quot;MOD_FALLING&quot; )<br /> {<br /> self thread playSwipeSound( sMeansOfDeath, eattacker );<br /> if( IS_TRUE(eattacker.is_zombie) || IsPlayer(eAttacker) )<br /> self PlayRumbleOnEntity( &quot;damage_heavy&quot; );<br /> <br /> if( IS_TRUE(eattacker.is_zombie) )<br /> {<br /> self zm_audio::create_and_play_dialog( &quot;general&quot;, &quot;attacked&quot; );<br /> }<br /> <br /> canExert = true;<br /> <br /> if ( IS_TRUE( level.pers_upgrade_flopper ) )<br /> {<br /> // If the player has persistent flopper power, then no exert on explosion<br /> if ( IS_TRUE( self.pers_upgrades_awarded[ &quot;flopper&quot; ] ) )<br /> {<br /> canExert = ( sMeansOfDeath != &quot;MOD_PROJECTILE_SPLASH&quot; &amp;&amp; sMeansOfDeath != &quot;MOD_GRENADE&quot; &amp;&amp; sMeansOfDeath != &quot;MOD_GRENADE_SPLASH&quot; );<br /> }<br /> }<br /> <br /> if ( IS_TRUE( canExert ) )<br /> {<br />    if(RandomIntRange(0,1) == 0 )<br />    {<br />     self thread zm_audio::playerExert( &quot;hitmed&quot; );<br />        //self thread zm_audio::create_and_play_dialog( &quot;general&quot;, &quot;hitmed&quot; );<br />    }<br />    else<br />    {<br />     self thread zm_audio::playerExert( &quot;hitlrg&quot; );<br />        //self thread zm_audio::create_and_play_dialog( &quot;general&quot;, &quot;hitlrg&quot; );<br />    }<br /> }<br /> }<br /> }<br /> <br /> //Audio(RG:2/1/2016) adding underwater drowning exert.<br /> if ( isDefined( sMeansOfDeath) &amp;&amp; sMeansOfDeath == &quot;MOD_DROWN&quot;)<br /> {<br /> self thread zm_audio::playerExert( &quot;drowning&quot;, true );<br /> self.voxDrowning = true;<br /> }<br /> <br /> if( isdefined( level.perk_damage_override ) )<br /> {<br /> foreach( func in level.perk_damage_override )<br /> {<br /> n_damage = self [[ func ]]( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime );<br /> if( isdefined( n_damage ) )<br /> {<br /> iDamage = n_damage; <br /> }<br /> }<br /> } <br /> finalDamage = iDamage;<br /> <br /> // claymores and freezegun shatters, like bouncing betties, harm no players<br /> if ( zm_utility::is_placeable_mine( weapon ) )<br /> {<br /> return 0;<br /> }<br /><br /> if ( isDefined( self.player_damage_override ) )<br /> {<br /> self thread [[ self.player_damage_override ]]( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime );<br /> } <br /> <br /> if ( sMeansOfDeath == &quot;MOD_PROJECTILE&quot; || sMeansOfDeath == &quot;MOD_PROJECTILE_SPLASH&quot; || sMeansOfDeath == &quot;MOD_GRENADE&quot; || sMeansOfDeath == &quot;MOD_GRENADE_SPLASH&quot; || sMeansOfDeath == &quot;MOD_EXPLOSIVE&quot; )<br /> {<br /> // player explosive splash damage (caps explosive damage), fixes raygun damage being fatal (or grenades) when damaging yourself<br /> if ( !IS_TRUE( self.is_zombie ) )<br /> {<br /> // Don&#39;t do this for projectile damage coming from zombies<br /> if ( !isdefined( eAttacker ) || ( !IS_TRUE( eAttacker.is_zombie ) &amp;&amp; !IS_TRUE( eAttacker.b_override_explosive_damage_cap ) ) )<br /> {<br /> // Only do it for ray gun<br /> if( isdefined(weapon.name) &amp;&amp; ((weapon.name == &quot;ray_gun&quot;) || ( weapon.name == &quot;ray_gun_upgraded&quot; )) )<br /> {<br /> // Clamp it, we don&#39;t want to increase the damage from player raygun splash damage or grenade splash damage<br /> // Don&#39;t create more damage than we are trying to apply<br /> if ( ( self.health &gt; 25 ) &amp;&amp; ( iDamage &gt; 25 ) )<br /> {<br /> return 25;<br /> }<br /> }<br /> else if ( ( self.health &gt; 75 ) &amp;&amp; ( iDamage &gt; 75 ) )<br /> {<br /> return 75;<br /> }<br /> }<br /> }<br /> }<br /><br /> if( iDamage &lt; self.health )<br /> {<br /> if ( IsDefined( eAttacker ) )<br /> {<br /> if( IsDefined( level.custom_kill_damaged_VO ) )<br /> {<br /> eAttacker thread [[ level.custom_kill_damaged_VO ]]( self );<br /> }<br /> else<br /> {<br /> eAttacker.sound_damage_player = self; <br /> }<br /> <br /> if( IS_TRUE( eAttacker.missingLegs ) )<br /> {<br />    self zm_audio::create_and_play_dialog( &quot;general&quot;, &quot;crawl_hit&quot; );<br /> }<br /> }<br /> <br /> // MM (08/10/09)<br /> return finalDamage;<br /> }<br /> <br /> //player died<br /> if( isdefined( eAttacker ) )<br /> {<br /> if(isDefined(eAttacker.animname) &amp;&amp; eAttacker.animname == &quot;zombie_dog&quot;)<br /> {<br /> self zm_stats::increment_client_stat( &quot;killed_by_zdog&quot; );<br /> self zm_stats::increment_player_stat( &quot;killed_by_zdog&quot; );<br /> }<br /> else if(IS_TRUE(eAttacker.is_avogadro))<br /> {<br /> self zm_stats::increment_client_stat( &quot;killed_by_avogadro&quot;, false );<br /> self zm_stats::increment_player_stat( &quot;killed_by_avogadro&quot; );<br /> }<br /> }<br /><br /> self thread clear_path_timers();<br /> <br /> if( level.intermission )<br /> {<br /> level waittill( &quot;forever&quot; );<br /> }<br /> <br /> // AR (3/7/12) - Keep track of which player killed player in Zombify modes like Cleansed / Turned<br /> // Confirmed with Alex <br /> if ( level.scr_zm_ui_gametype == &quot;zcleansed&quot; &amp;&amp; iDamage &gt; 0 )<br /> {<br /> if ( IsDefined( eAttacker ) &amp;&amp; IsPlayer( eAttacker ) &amp;&amp; eAttacker.team != self.team &amp;&amp; ( ( !IS_TRUE( self.laststand ) &amp;&amp; !self laststand::player_is_in_laststand() ) || !IsDefined( self.last_player_attacker ) ) )<br /> {<br /> // Restore Health To Zombie Player<br /> //--------------------------------<br /> if ( IsDefined( eAttacker.maxhealth ) &amp;&amp; IS_TRUE( eAttacker.is_zombie ) )<br /> {<br /> eAttacker.health = eAttacker.maxhealth;<br /> }<br /> <br /> //self.last_player_attacker = eAttacker;<br /><br /> if ( IsDefined( level.player_kills_player ) )<br /> {<br /> self thread [[ level.player_kills_player]]( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime );<br /> } <br /> }<br /> }<br /> <br /> if ( self.lives &gt; 0 &amp;&amp; self HasPerk( PERK_WHOSWHO ) )<br /> {<br /> self.lives--;<br /> if ( IsDefined( level.whoswho_laststand_func ) )<br /> {<br /> self thread [[ level.whoswho_laststand_func]]();<br /> return 0;<br /> } <br /> } <br /> <br /> players = GetPlayers();<br /> count = 0;<br /> for( i = 0; i &lt; players.size; i++ )<br /> {<br /> if( players<em>== self || players<em>.is_zombie || players<em>laststand::player_is_in_laststand() || players<em>.sessionstate == &quot;spectator&quot; )<br /> {<br /> count++;<br /> }<br /> }<br /> <br /> if( count &lt; players.size || (isDefined(level._game_module_game_end_check) &amp;&amp; ![[level._game_module_game_end_check]]()) )<br /> {<br /> if ( IsDefined( self.lives ) &amp;&amp; self.lives &gt; 0 &amp;&amp; IS_TRUE( level.force_solo_quick_revive ) &amp;&amp;  self HasPerk( PERK_QUICK_REVIVE ) )<br /> {<br /> self thread wait_and_revive();<br /> }<br /> <br /> // MM (08/10/09)<br /> return finalDamage;<br /> }<br /> <br /> // PORTIZ 7/27/16: added level.no_end_game_check here, because if it&#39;s true by this point, this function will end up returning finalDamage anyway. additionally, <br /> // no_end_game_check has been updated to support incrementing/decrementing, which makes it more robust than a single level.check_end_solo_game_override as more<br /> // mechanics are introduced that require solo players to go into last stand instead of losing the game immediately<br /> if ( players.size == 1 &amp;&amp; level flag::get( &quot;solo_game&quot; ) )<br /> {<br /> if ( IS_TRUE( level.no_end_game_check ) || ( isdefined( level.check_end_solo_game_override ) &amp;&amp; [[level.check_end_solo_game_override]]() ) )<br /> {<br /> return finalDamage;<br /> }<br /> else if ( self.lives == 0 || !self HasPerk( PERK_QUICK_REVIVE ) )<br /> {<br /> self.intermission = true;<br /> }<br /> }<br /> <br /> <br /> <br /> <br /> // WW (01/05/11): When a two players enter a system link game and the client drops the host will be treated as if it was a solo game<br /> // when it wasn&#39;t. This led to SREs about undefined and int being compared on death (self.lives was never defined on the host). While<br /> // adding the check for the solo game flag we found that we would have to create a complex OR inside of the if check below. By breaking<br /> // the conditions out in to their own variables we keep the complexity without making it look like a mess.<br /> solo_death = ( players.size == 1 &amp;&amp; level flag::get( &quot;solo_game&quot; ) &amp;&amp; ( self.lives == 0  || !self HasPerk(PERK_QUICK_REVIVE) ) ); // there is only one player AND the flag is set AND self.lives equals 0<br /> non_solo_death = ( ( count &gt; 1 || ( players.size == 1 &amp;&amp; !level flag::get( &quot;solo_game&quot; ) ) ) /*&amp;&amp; !level.is_zombie_level*/ ); // the player size is greater than one OR ( players.size equals 1 AND solo flag isn&#39;t set ) AND not a zombify game level<br /> if ( (solo_death || non_solo_death) &amp;&amp; !IS_TRUE(level.no_end_game_check ) ) // if only one player on their last life or any game that started with more than one player<br /> { <br /> level notify(&quot;stop_suicide_trigger&quot;);<br /> self AllowProne( true ); //just in case<br /> self thread zm_laststand::PlayerLastStand( eInflictor, eAttacker, iDamage, sMeansOfDeath, weapon, vDir, sHitLoc, psOffsetTime );<br /> if( !isdefined( vDir ) )<br /> {<br /> vDir = ( 1.0, 0.0, 0.0 );<br /> }<br /> self FakeDamageFrom(vDir);<br /> <br /> level notify(&quot;last_player_died&quot;);<br /> if ( isdefined(level.custom_player_fake_death) )<br /> self thread [[level.custom_player_fake_death]](vDir, sMeansOfDeath);<br /> else<br /> self thread player_fake_death();<br /> }<br /><br /> if( count == players.size &amp;&amp; !IS_TRUE( level.no_end_game_check ) )<br /> {<br /> if ( players.size == 1 &amp;&amp; level flag::get( &quot;solo_game&quot; ))<br /> {<br /> if ( self.lives == 0 || !self HasPerk(PERK_QUICK_REVIVE) ) // &amp;&amp; !self laststand::player_is_in_laststand()<br /> {<br /> self.lives = 0;<br /> level notify(&quot;pre_end_game&quot;);<br /> util::wait_network_frame();<br /> if(level flag::get(&quot;dog_round&quot;))<br /> {<br /> increment_dog_round_stat( &quot;lost&quot; ); <br /> <br /> } <br /> level notify( &quot;end_game&quot; );<br /> }<br /> else<br /> {<br /> return finalDamage;<br /> }<br /> }<br /> else<br /> {<br /> level notify(&quot;pre_end_game&quot;);<br /> util::wait_network_frame();<br /> if(level flag::get(&quot;dog_round&quot;))<br /> {<br /> increment_dog_round_stat( &quot;lost&quot; ); <br /> <br /> }<br /> level notify( &quot;end_game&quot; );<br /> }<br /> return 0; // MM (09/16/09) Need to return something<br /> }<br /> else<br /> {<br /> // MM (08/10/09)<br /> <br /> surface = &quot;flesh&quot;;<br /> <br /> return finalDamage;<br /> }<br />}<br /><br />function no_fall_damage()<br />{<br /> level flag::wait_till( &quot;all_players_connected&quot; ); // wait some time to overwrite the original <br /> level.overridePlayerDamage = &amp;player_damage_override;<br />}[/CODE]<br /><br /><br /><br />2) Place this in function main() of your mapname.gsc : <br /><br />[CODE=php]level thread no_fall_damage();[/CODE]<br /><br />Edit: Something is pretty wacked out with the copy and paste of code. <a href="http://paste.md-5.net/yitecequpo.php">Here</a> is the 2 functions in a paste link</em></em></em></em></p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: ByKris<br /><blockquote><em>natesmithzombies</em>You need to override the stock player_damage_override function. To do so: <br /><br /><br /><br />1) paste this at the bottom of your mapname.gsc <br /><br /><br /><br />[CODE=php]function player_damage_override( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime )<br />{<br /> iDamage = self check_player_damage_callbacks( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime );<br /> <br /> if( sMeansOfDeath == &quot;MOD_FALLING&quot; ) // No Fall Damage<br /> return 0; <br /> <br /> if( self.scene_takedamage === false )<br /> {<br /> return 0;<br /> }<br /> <br /> if ( IS_TRUE( self.use_adjusted_grenade_damage ) )<br />    {<br />        self.use_adjusted_grenade_damage = undefined;<br />        if( ( self.health &gt; iDamage ) )<br />        {<br />         return iDamage;<br />        }<br />    }<br /><br /> if ( !iDamage )<br /> {<br /> return 0;<br /> }<br /> <br /> // WW (8/20/10) - Sledgehammer fix for Issue 43492. This should stop the player from taking any damage while in laststand<br /> if( self laststand::player_is_in_laststand() )<br /> {<br /> return 0;<br /> }<br /> <br /> if ( isDefined( eInflictor ) )<br /> {<br /> if ( IS_TRUE( eInflictor.water_damage ) )<br /> {<br /> return 0;<br /> }<br /> }<br /><br /> if ( isDefined( eAttacker ) )<br /> {<br /> if( IS_EQUAL( eAttacker.owner, self ) ) <br /> {<br /> return 0;<br /> }<br /> <br /> if( isDefined( self.ignoreAttacker ) &amp;&amp; self.ignoreAttacker == eAttacker ) <br /> {<br /> return 0;<br /> }<br /> <br /> // AR (5/30/12) - Stop Zombie players from damaging other Zombie players<br /> if ( IS_TRUE( self.is_zombie ) &amp;&amp; IS_TRUE( eAttacker.is_zombie ) )<br /> {<br /> return 0;<br /> }<br /> <br /> if( (isDefined( eAttacker.is_zombie ) &amp;&amp; eAttacker.is_zombie) )<br /> {<br /> self.ignoreAttacker = eAttacker;<br /> self thread remove_ignore_attacker();<br /><br /> if ( isdefined( eAttacker.custom_damage_func ) )<br /> {<br /> iDamage = eAttacker [[ eAttacker.custom_damage_func ]]( self );<br /> }<br /> }<br /> <br /> eAttacker notify( &quot;hit_player&quot; ); <br /><br /> if ( isdefined( eAttacker ) &amp;&amp; isdefined( eAttacker.func_mod_damage_override ) )<br /> {<br /> sMeansOfDeath = eAttacker [[ eAttacker.func_mod_damage_override ]]( eInflictor, sMeansOfDeath, weapon );<br /> }<br /> <br /> if( sMeansOfDeath != &quot;MOD_FALLING&quot; )<br /> {<br /> self thread playSwipeSound( sMeansOfDeath, eattacker );<br /> if( IS_TRUE(eattacker.is_zombie) || IsPlayer(eAttacker) )<br /> self PlayRumbleOnEntity( &quot;damage_heavy&quot; );<br /> <br /> if( IS_TRUE(eattacker.is_zombie) )<br /> {<br /> self zm_audio::create_and_play_dialog( &quot;general&quot;, &quot;attacked&quot; );<br /> }<br /> <br /> canExert = true;<br /> <br /> if ( IS_TRUE( level.pers_upgrade_flopper ) )<br /> {<br /> // If the player has persistent flopper power, then no exert on explosion<br /> if ( IS_TRUE( self.pers_upgrades_awarded[ &quot;flopper&quot; ] ) )<br /> {<br /> canExert = ( sMeansOfDeath != &quot;MOD_PROJECTILE_SPLASH&quot; &amp;&amp; sMeansOfDeath != &quot;MOD_GRENADE&quot; &amp;&amp; sMeansOfDeath != &quot;MOD_GRENADE_SPLASH&quot; );<br /> }<br /> }<br /> <br /> if ( IS_TRUE( canExert ) )<br /> {<br />    if(RandomIntRange(0,1) == 0 )<br />    {<br />     self thread zm_audio::playerExert( &quot;hitmed&quot; );<br />        //self thread zm_audio::create_and_play_dialog( &quot;general&quot;, &quot;hitmed&quot; );<br />    }<br />    else<br />    {<br />     self thread zm_audio::playerExert( &quot;hitlrg&quot; );<br />        //self thread zm_audio::create_and_play_dialog( &quot;general&quot;, &quot;hitlrg&quot; );<br />    }<br /> }<br /> }<br /> }<br /> <br /> //Audio(RG:2/1/2016) adding underwater drowning exert.<br /> if ( isDefined( sMeansOfDeath) &amp;&amp; sMeansOfDeath == &quot;MOD_DROWN&quot;)<br /> {<br /> self thread zm_audio::playerExert( &quot;drowning&quot;, true );<br /> self.voxDrowning = true;<br /> }<br /> <br /> if( isdefined( level.perk_damage_override ) )<br /> {<br /> foreach( func in level.perk_damage_override )<br /> {<br /> n_damage = self [[ func ]]( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime );<br /> if( isdefined( n_damage ) )<br /> {<br /> iDamage = n_damage; <br /> }<br /> }<br /> } <br /> finalDamage = iDamage;<br /> <br /> // claymores and freezegun shatters, like bouncing betties, harm no players<br /> if ( zm_utility::is_placeable_mine( weapon ) )<br /> {<br /> return 0;<br /> }<br /><br /> if ( isDefined( self.player_damage_override ) )<br /> {<br /> self thread [[ self.player_damage_override ]]( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime );<br /> } <br /> <br /> if ( sMeansOfDeath == &quot;MOD_PROJECTILE&quot; || sMeansOfDeath == &quot;MOD_PROJECTILE_SPLASH&quot; || sMeansOfDeath == &quot;MOD_GRENADE&quot; || sMeansOfDeath == &quot;MOD_GRENADE_SPLASH&quot; || sMeansOfDeath == &quot;MOD_EXPLOSIVE&quot; )<br /> {<br /> // player explosive splash damage (caps explosive damage), fixes raygun damage being fatal (or grenades) when damaging yourself<br /> if ( !IS_TRUE( self.is_zombie ) )<br /> {<br /> // Don&#39;t do this for projectile damage coming from zombies<br /> if ( !isdefined( eAttacker ) || ( !IS_TRUE( eAttacker.is_zombie ) &amp;&amp; !IS_TRUE( eAttacker.b_override_explosive_damage_cap ) ) )<br /> {<br /> // Only do it for ray gun<br /> if( isdefined(weapon.name) &amp;&amp; ((weapon.name == &quot;ray_gun&quot;) || ( weapon.name == &quot;ray_gun_upgraded&quot; )) )<br /> {<br /> // Clamp it, we don&#39;t want to increase the damage from player raygun splash damage or grenade splash damage<br /> // Don&#39;t create more damage than we are trying to apply<br /> if ( ( self.health &gt; 25 ) &amp;&amp; ( iDamage &gt; 25 ) )<br /> {<br /> return 25;<br /> }<br /> }<br /> else if ( ( self.health &gt; 75 ) &amp;&amp; ( iDamage &gt; 75 ) )<br /> {<br /> return 75;<br /> }<br /> }<br /> }<br /> }<br /><br /> if( iDamage &lt; self.health )<br /> {<br /> if ( IsDefined( eAttacker ) )<br /> {<br /> if( IsDefined( level.custom_kill_damaged_VO ) )<br /> {<br /> eAttacker thread [[ level.custom_kill_damaged_VO ]]( self );<br /> }<br /> else<br /> {<br /> eAttacker.sound_damage_player = self; <br /> }<br /> <br /> if( IS_TRUE( eAttacker.missingLegs ) )<br /> {<br />    self zm_audio::create_and_play_dialog( &quot;general&quot;, &quot;crawl_hit&quot; );<br /> }<br /> }<br /> <br /> // MM (08/10/09)<br /> return finalDamage;<br /> }<br /> <br /> //player died<br /> if( isdefined( eAttacker ) )<br /> {<br /> if(isDefined(eAttacker.animname) &amp;&amp; eAttacker.animname == &quot;zombie_dog&quot;)<br /> {<br /> self zm_stats::increment_client_stat( &quot;killed_by_zdog&quot; );<br /> self zm_stats::increment_player_stat( &quot;killed_by_zdog&quot; );<br /> }<br /> else if(IS_TRUE(eAttacker.is_avogadro))<br /> {<br /> self zm_stats::increment_client_stat( &quot;killed_by_avogadro&quot;, false );<br /> self zm_stats::increment_player_stat( &quot;killed_by_avogadro&quot; );<br /> }<br /> }<br /><br /> self thread clear_path_timers();<br /> <br /> if( level.intermission )<br /> {<br /> level waittill( &quot;forever&quot; );<br /> }<br /> <br /> // AR (3/7/12) - Keep track of which player killed player in Zombify modes like Cleansed / Turned<br /> // Confirmed with Alex <br /> if ( level.scr_zm_ui_gametype == &quot;zcleansed&quot; &amp;&amp; iDamage &gt; 0 )<br /> {<br /> if ( IsDefined( eAttacker ) &amp;&amp; IsPlayer( eAttacker ) &amp;&amp; eAttacker.team != self.team &amp;&amp; ( ( !IS_TRUE( self.laststand ) &amp;&amp; !self laststand::player_is_in_laststand() ) || !IsDefined( self.last_player_attacker ) ) )<br /> {<br /> // Restore Health To Zombie Player<br /> //--------------------------------<br /> if ( IsDefined( eAttacker.maxhealth ) &amp;&amp; IS_TRUE( eAttacker.is_zombie ) )<br /> {<br /> eAttacker.health = eAttacker.maxhealth;<br /> }<br /> <br /> //self.last_player_attacker = eAttacker;<br /><br /> if ( IsDefined( level.player_kills_player ) )<br /> {<br /> self thread [[ level.player_kills_player]]( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, weapon, vPoint, vDir, sHitLoc, psOffsetTime );<br /> } <br /> }<br /> }<br /> <br /> if ( self.lives &gt; 0 &amp;&amp; self HasPerk( PERK_WHOSWHO ) )<br /> {<br /> self.lives--;<br /> if ( IsDefined( level.whoswho_laststand_func ) )<br /> {<br /> self thread [[ level.whoswho_laststand_func]]();<br /> return 0;<br /> } <br /> } <br /> <br /> players = GetPlayers();<br /> count = 0;<br /> for( i = 0; i &lt; players.size; i++ )<br /> {<br /> if( players<em>== self || players<em>.is_zombie || players<em>laststand::player_is_in_laststand() || players<em>.sessionstate == &quot;spectator&quot; )<br /> {<br /> count++;<br /> }<br /> }<br /> <br /> if( count &lt; players.size || (isDefined(level._game_module_game_end_check) &amp;&amp; ![[level._game_module_game_end_check]]()) )<br /> {<br /> if ( IsDefined( self.lives ) &amp;&amp; self.lives &gt; 0 &amp;&amp; IS_TRUE( level.force_solo_quick_revive ) &amp;&amp;  self HasPerk( PERK_QUICK_REVIVE ) )<br /> {<br /> self thread wait_and_revive();<br /> }<br /> <br /> // MM (08/10/09)<br /> return finalDamage;<br /> }<br /> <br /> // PORTIZ 7/27/16: added level.no_end_game_check here, because if it&#39;s true by this point, this function will end up returning finalDamage anyway. additionally, <br /> // no_end_game_check has been updated to support incrementing/decrementing, which makes it more robust than a single level.check_end_solo_game_override as more<br /> // mechanics are introduced that require solo players to go into last stand instead of losing the game immediately<br /> if ( players.size == 1 &amp;&amp; level flag::get( &quot;solo_game&quot; ) )<br /> {<br /> if ( IS_TRUE( level.no_end_game_check ) || ( isdefined( level.check_end_solo_game_override ) &amp;&amp; [[level.check_end_solo_game_override]]() ) )<br /> {<br /> return finalDamage;<br /> }<br /> else if ( self.lives == 0 || !self HasPerk( PERK_QUICK_REVIVE ) )<br /> {<br /> self.intermission = true;<br /> }<br /> }<br /> <br /> <br /> <br /> <br /> // WW (01/05/11): When a two players enter a system link game and the client drops the host will be treated as if it was a solo game<br /> // when it wasn&#39;t. This led to SREs about undefined and int being compared on death (self.lives was never defined on the host). While<br /> // adding the check for the solo game flag we found that we would have to create a complex OR inside of the if check below. By breaking<br /> // the conditions out in to their own variables we keep the complexity without making it look like a mess.<br /> solo_death = ( players.size == 1 &amp;&amp; level flag::get( &quot;solo_game&quot; ) &amp;&amp; ( self.lives == 0  || !self HasPerk(PERK_QUICK_REVIVE) ) ); // there is only one player AND the flag is set AND self.lives equals 0<br /> non_solo_death = ( ( count &gt; 1 || ( players.size == 1 &amp;&amp; !level flag::get( &quot;solo_game&quot; ) ) ) /*&amp;&amp; !level.is_zombie_level*/ ); // the player size is greater than one OR ( players.size equals 1 AND solo flag isn&#39;t set ) AND not a zombify game level<br /> if ( (solo_death || non_solo_death) &amp;&amp; !IS_TRUE(level.no_end_game_check ) ) // if only one player on their last life or any game that started with more than one player<br /> { <br /> level notify(&quot;stop_suicide_trigger&quot;);<br /> self AllowProne( true ); //just in case<br /> self thread zm_laststand::PlayerLastStand( eInflictor, eAttacker, iDamage, sMeansOfDeath, weapon, vDir, sHitLoc, psOffsetTime );<br /> if( !isdefined( vDir ) )<br /> {<br /> vDir = ( 1.0, 0.0, 0.0 );<br /> }<br /> self FakeDamageFrom(vDir);<br /> <br /> level notify(&quot;last_player_died&quot;);<br /> if ( isdefined(level.custom_player_fake_death) )<br /> self thread [[level.custom_player_fake_death]](vDir, sMeansOfDeath);<br /> else<br /> self thread player_fake_death();<br /> }<br /><br /> if( count == players.size &amp;&amp; !IS_TRUE( level.no_end_game_check ) )<br /> {<br /> if ( players.size == 1 &amp;&amp; level flag::get( &quot;solo_game&quot; ))<br /> {<br /> if ( self.lives == 0 || !self HasPerk(PERK_QUICK_REVIVE) ) // &amp;&amp; !self laststand::player_is_in_laststand()<br /> {<br /> self.lives = 0;<br /> level notify(&quot;pre_end_game&quot;);<br /> util::wait_network_frame();<br /> if(level flag::get(&quot;dog_round&quot;))<br /> {<br /> increment_dog_round_stat( &quot;lost&quot; ); <br /> <br /> } <br /> level notify( &quot;end_game&quot; );<br /> }<br /> else<br /> {<br /> return finalDamage;<br /> }<br /> }<br /> else<br /> {<br /> level notify(&quot;pre_end_game&quot;);<br /> util::wait_network_frame();<br /> if(level flag::get(&quot;dog_round&quot;))<br /> {<br /> increment_dog_round_stat( &quot;lost&quot; ); <br /> <br /> }<br /> level notify( &quot;end_game&quot; );<br /> }<br /> return 0; // MM (09/16/09) Need to return something<br /> }<br /> else<br /> {<br /> // MM (08/10/09)<br /> <br /> surface = &quot;flesh&quot;;<br /> <br /> return finalDamage;<br /> }<br />}<br /><br />function no_fall_damage()<br />{<br /> level flag::wait_till( &quot;all_players_connected&quot; ); // wait some time to overwrite the original <br /> level.overridePlayerDamage = &amp;player_damage_override;<br />}[/CODE]<br /><br /><br /><br />2) Place this in function main() of your mapname.gsc : <br /><br />[CODE=php]level thread no_fall_damage();[/CODE]<br /><br />Edit: Something is pretty wacked out with the copy and paste of code. <a href="http://paste.md-5.net/yitecequpo.php">Here</a> is the 2 functions in a paste link[/QUOTE]<br /><br />^1}<br /><br />^1^<br /><br />^1ERR(6E) scripts/zm/zm_impossible.gsc (381,1) : Compiler Internal Error : Uninitialized local variable &#39;perk_whoswho&#39;<br /><br /><br /><br />By the way my character has 50 not 77 of life</em></em></em></em></blockquote></p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: natesmithzombies<br /><blockquote><em>ByKris</em>^1}<br /><br />^1^<br /><br />^1ERR(6E) scripts/zm/zm_impossible.gsc (381,1) : Compiler Internal Error : Uninitialized local variable &#39;perk_whoswho&#39;<br /><br /><br /><br />By the way my character has 50 not 77 of life</blockquote><br /><br />One/more of the .gsh files need to be included using the #include call in your mapname.gsc somewhere.</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: ByKris<br /><blockquote><em>natesmithzombies</em><blockquote><em>ByKris</em>^1}<br /><br />^1^<br /><br />^1ERR(6E) scripts/zm/zm_impossible.gsc (381,1) : Compiler Internal Error : Uninitialized local variable &#39;perk_whoswho&#39;<br /><br /><br /><br />By the way my character has 50 not 77 of life</blockquote><br /><br />One/more of the .gsh files need to be included using the #include call in your mapname.gsc somewhere. </blockquote><br /><br />And what do i need include?</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: natesmithzombies<br /><blockquote><em>ByKris</em><blockquote><em>natesmithzombies</em><blockquote><em>ByKris</em>^1}<br /><br />^1^<br /><br />^1ERR(6E) scripts/zm/zm_impossible.gsc (381,1) : Compiler Internal Error : Uninitialized local variable &#39;perk_whoswho&#39;<br /><br /><br /><br />By the way my character has 50 not 77 of life</blockquote><br /><br />One/more of the .gsh files need to be included using the #include call in your mapname.gsc somewhere. </blockquote><br /><br />And what do i need include?</blockquote><br /><br />At the top of your mapname.gsc add any of these that are missing: <br /><br />[CODE=php]#using scripts\codescripts\struct; #using scripts\shared\array_shared; #using scripts\shared\clientfield_shared; #using scripts\shared\system_shared; #using scripts\shared\util_shared; #using scripts\shared\visionset_mgr_shared; #using scripts\zm\_zm_score; #insert scripts\shared\shared.gsh; #insert scripts\shared\version.gsh; #using scripts\zm\_zm_audio; #using scripts\shared\flag_shared; #using scripts\shared\laststand_shared; #using scripts\zm\_zm_laststand; #using scripts\shared\ai\zombie_utility; #using scripts\zm\_util; #using scripts\zm\_zm_perks; #using scripts\zm\_zm_pers_upgrades; #using scripts\zm\_zm_pers_upgrades_functions; #using scripts\zm\_zm_pers_upgrades_system; #using scripts\zm\_zm_stats; #using scripts\zm\_zm_utility; #insert scripts\zm\_zm_perk_juggernaut.gsh; #insert scripts\zm\_zm_perks.gsh; #insert scripts\zm\_zm_utility.gsh; #insert scripts\shared\ai\zombie.gsh;[/CODE]</p>

---
<strong style="font-size: 1.4em;"><span style="text-decoration: underline;text-decoration-color: #34a7f9;"><span style="color:#34a7f9;">ModmeBot</span></span>:</strong>

<p>Reply By: ByKris<br /><blockquote><em>natesmithzombies</em><blockquote><em>ByKris</em><blockquote><em>natesmithzombies</em><blockquote><em>ByKris</em>^1}<br /><br />^1^<br /><br />^1ERR(6E) scripts/zm/zm_impossible.gsc (381,1) : Compiler Internal Error : Uninitialized local variable &#39;perk_whoswho&#39;<br /><br /><br /><br />By the way my character has 50 not 77 of life</blockquote><br /><br />One/more of the .gsh files need to be included using the #include call in your mapname.gsc somewhere. </blockquote><br /><br />And what do i need include?</blockquote><br /><br />At the top of your mapname.gsc add any of these that are missing: <br /><br />[CODE=php]#using scripts\codescripts\struct; #using scripts\shared\array_shared; #using scripts\shared\clientfield_shared; #using scripts\shared\system_shared; #using scripts\shared\util_shared; #using scripts\shared\visionset_mgr_shared; #using scripts\zm\_zm_score; #insert scripts\shared\shared.gsh; #insert scripts\shared\version.gsh; #using scripts\zm\_zm_audio; #using scripts\shared\flag_shared; #using scripts\shared\laststand_shared; #using scripts\zm\_zm_laststand; #using scripts\shared\ai\zombie_utility; #using scripts\zm\_util; #using scripts\zm\_zm_perks; #using scripts\zm\_zm_pers_upgrades; #using scripts\zm\_zm_pers_upgrades_functions; #using scripts\zm\_zm_pers_upgrades_system; #using scripts\zm\_zm_stats; #using scripts\zm\_zm_utility; #insert scripts\zm\_zm_perk_juggernaut.gsh; #insert scripts\zm\_zm_perks.gsh; #insert scripts\zm\_zm_utility.gsh; #insert scripts\shared\ai\zombie.gsh;[/CODE]<br /><br /></blockquote><br /><br />Thanx nates!</p>
